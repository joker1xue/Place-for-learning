23.05.30

//函数高级 函数的默认参数

//如果某个位置的参数有默认值，那么这个位置之后的所有参数都必须有默认值
int func(int a,int b,int c=10)
//在这里c具有默认值，由于是最后一个参数，所以不会报错，但是如果是a有默认值而bc任一没有或者b有而c没有，则会报错
{
  return a+b+c;
}
int main()
{
  func(10,20);//在调用时，因为c有默认值，所以此时没有c的实参时，参与函数执行的c值就是默认值，也可以为c赋予实参。
  //这个时候的参数列表数量必须满足函数中无默认值的参数个数，由于具有默认值的参数之后的参数都必须有默认值，所以很清楚的是，使用函数
  //时参数列表就是从第一个开始往后传值直到最后一个无默认值的形参。
  system("pause");
  return 0;
}






//如果函数声明的时候参数有默认值，那么函数实现的时候就不能有默认值

int func(int a,int b,int c=10);

int func(int a,int b,int c=10)//不报错，但是运行错误，编译器编译时不知道该使用哪个默认值
{
  return a+b+c;
}





//函数的占位参数
//返回值类型 函数名(数据类型){}
void func(int a, int )//这里可以只留一个数据类型，用于"占位"，占位参数也有默认参数
{
  cout << "hello world" << endl;
}

int main()
{
  func(10,10);//若占位参数没有默认参数，则在调用时必须填补占位参数，若有，则可以不填补
}

//作用：待补充






//函数重载
//函数重载的条件：同一作用域下；函数名称相同；参数列表不同。   与返回值类型无关。

//函数重载的注意事项：（1）引用作为重载的条件；（2）重载碰到默认参数。

//（1）：引用作为重载条件
void func(int& a)
{
  cout << "func(int& a)" << endl;
}

void func(const int& a)
{
  cout << "func(const int& a)" << endl;
}
//在这里发生了函数重载，使用的const使函数的参数列表不同，在main函数中调用时，传入参数为变量时调用前者，为常量是调用后者，例如：
int main()
{
  int a = 10;
  func(a);//调用前者
  func(10);//调用后者
}
//总而言之，就是在调用函数传入不同的参数时，编译器都能毫无疑问的匹配到唯一一个可执行的函数，这样使用相同名字的函数就算成功且合法的重载






//（2）重载碰到默认参数

void func(int a,int b=10)
{
  cout << "func(int a,int b=10)" << endl;
}

void func(int a)
{
  cout << "func(int a)" << endl;
}
//目前为止，以上的函数满足同一作用域、函数名相同、参数列表不同，似乎并没有异常，但是若在main函数中进行如下的调用：
func(10);
//试着去推断一下编译器会怎么处理这个调用，该如何选择调用的函数呢？
//毫无疑问，无论调用哪个函数都是合法的调用，这样编译器会无法选择调用的函数，这个时候在程序编译过程中就会出错。
//因此，在使用重载的过程中要避免使用默认参数。









